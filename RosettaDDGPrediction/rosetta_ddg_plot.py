#!/usr/bin/env python
# -*- Mode: python; tab-width: 4; indent-tabs-mode:nil; coding:utf-8 -*-

#    rosetta_ddg_plot.py
#
#    Plot aggregated data generated by running Rosetta protocols for
#    the calculation of the ΔΔG of stability/binding upon mutation.
#
#    Copyright (C) 2020 Valentina Sora 
#                       <sora.valentina1@gmail.com>
#                       Matteo Tiberti 
#                       <matteo.tiberti@gmail.com> 
#                       Elena Papaleo
#                       <elenap@cancer.dk>
#
#    This program is free software: you can redistribute it and/or
#    modify it under the terms of the GNU General Public License as
#    published by the Free Software Foundation, either version 3 of
#    the License, or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public
#    License along with this program. 
#    If not, see <http://www.gnu.org/licenses/>.



# standard library
import argparse
import logging as log
import os
import os.path
import sys
# third-party packages
import matplotlib.pyplot as plt
import pandas as pd
import yaml
# RosettaDDGProtocols
from .defaults import (
     CONFIGAGGRDIR,
     CONFIGAGGRFILE,
     CONFIGPLOTDIR,
     CONFIGRUNDIR,
     PLOTTYPES,
     ROSETTADFCOLS
)
from . import plotting
from . import util



def main():



    ######################### ARGUMENT PARSER #########################



    # set the argument parser
    parser = argparse.ArgumentParser()

    # add arguments
    i_help = "Input CSV file (aggregated data)."
    parser.add_argument("-i", "--infile", \
                        type = str, \
                        required = True, \
                        help = i_help)

    o_help = "Output file containing the plot."
    parser.add_argument("-o", "--outfile", \
                        type = str, \
                        required = True, \
                        help = o_help)

    ca_help = f"Configuration file used for data aggregation. " \
              f"If it is a name without extension, it is assumed " \
              f"to be the name of a YAML file in {CONFIGAGGRDIR}. " \
              f"Default is {CONFIGAGGRFILE}."
    parser.add_argument("-ca", "--configfile-aggregate", \
                        type = str, \
                        default = CONFIGAGGRFILE, 
                        help = ca_help)

    cp_help = \
        f"Configuration file for plotting. If it is a name " \
        f"without extension, it is assumed to be the name " \
        f"of a YAML file in {CONFIGPLOTDIR}."
    parser.add_argument("-cp", "--configfile-plot", \
                        type = str, \
                        required = True, 
                        help = cp_help)

    d2m_help = "File mapping the names of the directories " \
               "containing mutations included in a saturation " \
               "mutagenesis scan to the mutations themselves, " \
               "represented as in the mutations' list file " \
               "used to perform the scan. Required only if " \
               "the plot is total_heatmap_saturation." 
    parser.add_argument("-d2m", "--d2mfile", \
                        type = str, \
                        default = None, \
                        help = d2m_help)


    # parse the arguments
    args = parser.parse_args()
    # files
    infile = util.get_abspath(args.infile)
    outfile = util.get_abspath(args.outfile)
    d2mfile = util.get_abspath(args.d2mfile)
    # configuration files
    configfileplot = args.configfile_plot
    configfileaggr = args.configfile_aggregate


    # get the name of the configuration file for data
    # aggregation
    configaggrname = \
        os.path.basename(configfileaggr).rstrip(".yaml")
    # get the name of the configuration file for plotting
    configplotname = \
        os.path.basename(configfileplot).rstrip(".yaml")


    # if the configuration file is a name without extension
    if configfileaggr == configaggrname:
        # assume it is a file in the directory where
        # configuration files for data aggregation are stored
        configfileaggr = os.path.join(CONFIGAGGRDIR, \
                                      configaggrname + ".yaml")
    # otherwise assume it is a file name/file path
    else:
        configfileaggr = util.get_abspath(configfileaggr)

    # if the configuration file is a name without extension
    if configfileplot == configplotname:
        # assume it is a file in the directory where
        # configuration files for plotting are stored
        configfileplot = os.path.join(CONFIGPLOTDIR, \
                                      configplotname + ".yaml")
    # otherwise assume it is a file name/file path
    else:
        configfileplot = util.get_abspath(configfileplot)



    ############################# LOGGING #############################



    # logging configuration
    log.basicConfig(level = log.INFO)



    ########################## CONFIGURATION ##########################


    
    # try to get the aggregation configuration
    try:
        configaggr = yaml.safe_load(open(configfileaggr))
    # if something goes wrong, report it and exit
    except Exception as e:
        log.error(f"Could not parse {configfileaggr}: {e}")
        sys.exit(1)
    
    # try to get the plot+output configuration
    try:
        configplot = plotting.get_config_plot(configfile = configfileplot)
    # if something goes wrong, report it and exit
    except Exception as e:
        log.error(f"Could not parse {configfileplot}: {e}")
        sys.exit(1)

    # get the plot type
    plottype = configplot["plot"]["type"]
    
    # get the plot options
    config = configplot["plot"]["options"]



    ######################### PLOT GENERATION #########################



    # try to load the dataframe
    try:
        df = pd.read_csv(infile)
    # if something goes wrong, report it and exit
    except Exception as e:
        log.error(f"Could not load {infile}: {e}")
        sys.exit(1)
 

    # get the scoring function name
    scfname = df[ROSETTADFCOLS["scfname"]].unique()[0]


    # try to generate the plot
    try:

        # if the plot is a heatmap of total scores
        if plottype == "total_heatmap":
            ax = plotting.plot_total_heatmap(df = df, \
                                             config = config)

        # if the plot is a heatmap for a saturation mutagenesis scan
        elif plottype == "total_heatmap_saturation":
            ax = plotting.plot_total_heatmap(df = df, \
                                             config = config, \
                                             saturation = True, \
                                             d2mfile = d2mfile)

        # if the plot is a barplot separating its total score into
        # its energy contributions
        elif plottype == "contributions_barplot":
            contributions = configaggr["energy_contributions"][scfname]
            ax = plotting.plot_contributions_barplot(\
                                    df = df, \
                                    config = config, \
                                    contributions = contributions)

        # if the plot is a swarmplot showing the distributions of
        # total scores for both wild-type and mutant structures
        elif plottype == "dg_swarmplot":
            ax = plotting.plot_dg_swarmplot(df = df, \
                                            config = config)

        # if another plot type was passed, report it and exit
        else:
            log.error(f"Unrecognized plot type {plottype}.")
            sys.exit(1)


    # if something goes wrong, report it and exit
    except Exception as e:
        log.error(f"Could not generate the {plottype} plot: {e}")
        sys.exit(1)


    # for top and right spine of the plot
    for spine in ["top", "right"]:
        # hide it
        ax.spines[spine].set_visible(False)


    # save the plot to the output file
    plt.savefig(outfile, **configplot.get("output", {}))


if __name__ == "__main__":
    main()